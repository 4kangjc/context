[/
          Copyright Oliver Kowalke 2014.
 Distributed under the Boost Software License, Version 1.0.
    (See accompanying file LICENSE_1_0.txt or copy at
          http://www.boost.org/LICENSE_1_0.txt
]

[#ccontext]
[section:ccontext Class captured_context]

Class __ccontext__ encapsulates __fcontext__ and manages the context' stack
(allocation/deallocation).

__ccontext__ allocates the context stack (using its __stack_allocator__
argument) and creates a control structure on top of it. This structure
controls the life time of the stack. The address of the control structure is
stored in the first frame of context' stack (e.g. it can not accessed by
instances of __ccontext__ directly). In contrast to __econtext__ the ownership
of the control structure is not shared
A call of__cc_op__ enters the context represented by `*this` and invalidates
`*this`. The context that has been suspended by calling __cc_op__ is passed to
the resumed context, e.g. as argument of the context-function if the context was
resumed the first time or returned by __cc_op__.
__ccontext__ is  only move-constructible and move-assignable.
If the last reference (__ccontext__) goes out of scope, the control structure
is destroyed and the stack gets deallocated via the __stack_allocator__.
__ccontext__ maintains a static, thread-local pointer (smart pointer),
accessed by __ec_current__,  pointing to the active context.
On each context switch the static, thread-local pointer is updated. This makes
the context switch a little bit slower, but enables faster context destruction
(stack unwinding) compared to __ccontext__.

__ccontext__ expects a function/functor with signature
`captured_context( captured_context ctx, void * vp)`. The parameter `ctx`
represents the context from which this context was resumed (e.g. that has called
__cc_op__ on `*this`) and `vp` is the data passed to __cc_op__. The
function/functor has to return the captured_context that has to be resumed,
while this context terminates.

[important Segemnted stacks are not supported together with __ccontext__.]


[heading usage of __ccontext__]

        /*
         * grammar:
         *   P ---> E '\0'
         *   E ---> T {('+'|'-') T}
         *   T ---> S {('*'|'/') S}
         *   S ---> digit | '(' E ')'
         */
        class Parser{
            // implementation omitted; see examples directory
        };

        std::istringstream is("1+1");
        bool done=false;
        std::exception_ptr except;

        // execute parser in new execution context
        boost::context::captured_context pctx(
                [&is,&done,&except](ctx::captured_context mctx,void* ignored){
                // create parser with callback function
                Parser p( is,
                          [&mctx](char ch){
                                // resume main execution context
                                auto result = mctx( & ch);
                                mctx = std::move( std::get<0>( result) );
                        });
                    try {
                        // start recursive parsing
                        p.run();
                    } catch ( ... ) {
                        // store other exceptions in exception-pointer
                        except = std::current_exception();
                    }
                    // set termination flag
                    done=true;
                    // resume main execution context
                    return mctx;
                });

        // user-code pulls parsed data from parser
        // invert control flow
        auto result = pctx();
        pctx = std::move( std::get<0>( result) );
        void * vp = std::get<1>( result);
        if ( except) {
            std::rethrow_exception( except);
        }
        while( ! done) {
            printf("Parsed: %c\n",* static_cast< char* >( vp) );
            std::tie(pctx,vp) = pctx();
            if ( except) {
                std::rethrow_exception( except);
            }
        }

        output:
            Parsed: 1
            Parsed: +
            Parsed: 1


In this example a recursive descent parser uses a callback to emit a newly
passed symbol. Using __ccontext__ the control flow can be inverted, e.g. the
user-code pulls parsed symbols from the parser - instead to get pushed from the
parser (via callback).

The data (character) is transferred between the two __ccontext__.

If the code executed by __ccontext__ emits an exception, the application is
terminated. ['std::exception_ptr] can be used to transfer exceptions between
different execution contexts.

Sometimes it is necessary to unwind the stack of an unfinished context to
destroy local stack variables so they can release allocated resources (RAII
pattern). The user is responsible for this task.

[heading allocating control structures on top of stack]
Allocating control structures on top of the stack requires to allocated the
__stack_context__ and create the control structure with placement new before
__ccontext__ is created.
[note The user is responsible for destructing the control structure at the top
of the stack.]

        // stack-allocator used for (de-)allocating stack
        fixedsize_stack salloc( 4048);
        // allocate stack space
        stack_context sctx( salloc.allocate() );
        // reserve space for control structure on top of the stack
        void * sp = static_cast< char * >( sctx.sp) - sizeof( my_control_structure);
        std::size_t size = sctx.size - sizeof( my_control_structure);
        // placement new creates control structure on reserved space
        my_control_structure * cs = new ( sp) my_control_structure( sp, size, sctx, salloc);
        ...
        // destructing the control structure
        cs->~my_control_structure();
        ...
        struct my_control_structure  {
            // captured context
            captured_context cctx;

            template< typename StackAllocator >
            my_control_structure( void * sp, std::size_t size, stack_context sctx, StackAllocator salloc) :
                // create captured context
                cctx( std::allocator_arg, preallocated( sp, size, sctx), salloc, entry_func) {
            }
            ...
        };

[heading exception handling]
If the function executed inside a __ccontext__ emits ans exception, the
application is terminated by calling ['std::terminate(). ['std::exception_ptr]
can be used to transfer exceptions between different execution contexts.

[heading parameter passing]
The void pointer argument passed to __cc_op__, in one context, is passed as
the last argument of the __context_fn__ if the context is started for the
first time.
In all following invocations of __cc_op__ the void pointer passed to
__cc_op__, in one context, is returned by __cc_op__ in the other context.

        class X {
        private:
            std::exception_ptr excptr_;
            boost::context::captured_context ctx_;

        public:
            X() :
                excptr_(),
                ctx_( [=](ctx::captured_context ctx, void * vp)->ctx::captured_context{
                            try {
                                for (;;) {
                                    int i = * static_cast< int * >( vp);
                                    std::string str = boost::lexical_cast<std::string>(i);
                                    auto result = ctx( & str);
                                    ctx = std::move( std::get<0>( result) );
                                    vp = std::get<1>( result);
                                }
                            } catch ( ctx::detail::forced_unwind const&) {
                                throw;
                            } catch (...) {
                                excptr_=std::current_exception();
                            }
                            return ctx;
                      })
            {}

            std::string operator()( int i) {
                auto result = ctx_( & i);
                ctx_ = std::move( std::get<0>( result) );
                void * ret = std::get<1>( result);
                if(excptr_){
                    std::rethrow_exception(excptr_);
                }
                return * static_cast< std::string * >( ret);
            }
        };

        X x;
        std::cout << x( 7) << std::endl;

        output:
        7


[heading Class `captured_context`]

        class captured_context {
        public:
            template< typename Fn, typename ... Args >
            captured_context( Fn && fn, Args && ... args);

            template< typename StackAlloc, typename Fn, typename ... Args >
            captured_context( std::allocator_arg_t, StackAlloc salloc, Fn && fn, Args && ... args);

            template< typename StackAlloc, typename Fn, typename ... Args >
            captured_context( std::allocator_arg_t, preallocated palloc, StackAlloc salloc, Fn && fn, Args && ... args);
    
            ~captured_context();

            captured_context( captured_context && other) noexcept;
            captured_context & operator=( captured_context && other) noexcept;

            captured_context( captured_context const& other) noexcept = delete;
            captured_context & operator=( captured_context const& other) noexcept = delete;

            explicit operator bool() const noexcept;
            bool operator!() const noexcept;

            std::tuple< captured_context, void * > operator()( void * data = nullptr);

            template< typename Fn, typename ... Args >
            std::tuple< captured_context, void * > operator()( exec_ontop_arg_t, Fn && fn, Args && ... args);

            template< typename Fn, typename ... Args >
            std::tuple< captured_context, void * > operator()( void * data, exec_ontop_arg_t, Fn && fn, Args && ... args);

            bool operator==( captured_context const& other) const noexcept;

            bool operator!=( captured_context const& other) const noexcept;

            bool operator<( captured_context const& other) const noexcept;

            bool operator>( captured_context const& other) const noexcept;

            bool operator<=( captured_context const& other) const noexcept;

            bool operator>=( captured_context const& other) const noexcept;

            template< typename charT, class traitsT >
            friend std::basic_ostream< charT, traitsT > &
            operator<<( std::basic_ostream< charT, traitsT > & os, captured_context const& other);
        };

[constructor_heading captured_context..constructor]

    template< typename Fn, typename ... Args >
    captured_context( Fn && fn, Args && ... args);
    
    template< typename StackAlloc, typename Fn, typename ... Args >
    captured_context( std::allocator_arg_t, StackAlloc salloc, Fn && fn, Args && ... args);
    
    template< typename StackAlloc, typename Fn, typename ... Args >
    captured_context( std::allocator_arg_t, preallocated palloc, StackAlloc salloc, Fn && fn, Args && ... args);

[variablelist
[[Effects:] [Creates a new execution context and prepares the context to execute
`fn`. `fixedsize_stack` is used as default stack allocator (stack size == fixedsize_stack::traits::default_size().]]
]
[[Effects:] [Creates a new execution context and prepares the context to execute
`fn`.]]
]
[[Effects:] [Creates a new execution context and prepares the context to execute
`fn`. Used to store control structures on top of the stack.]]
]

[move_constructor_heading captured_context..move constructor]

    captured_context( captured_context && other) noexcept;

[variablelist
[[Effects:] [Moves underlying capture record to `*this`.]]
[[Throws:] [Nothing.]]
]

[move_assignment_heading captured_context..move assignment]

    captured_context & operator=( captured_context && other) noexcept;

[variablelist
[[Effects:] [Moves the state of `other` to `*this` using move semantics.]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_bool..operator bool]

    explicit operator bool() const noexcept;

[variablelist
[[Returns:] [`true` if `*this` points to a capture record.]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_not..operator!]

    bool operator!() const noexcept;

[variablelist
[[Returns:] [`true` if `*this` does not point to a capture record.]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_call..operator()]

            std::tuple< captured_context, void * > operator()( void * data = nullptr);

            template< typename Fn, typename ... Args >
            std::tuple< captured_context, void * > operator()( exec_ontop_arg_t, Fn && fn, Args && ... args);

            template< typename Fn, typename ... Args >
            std::tuple< captured_context, void * > operator()( void * data, exec_ontop_arg_t, Fn && fn, Args && ... args);

[variablelist
[[Effects:] [Stores internally the current context data (stack pointer,
instruction pointer, and CPU registers) of the current active context and
restores the context data from `*this`, which implies jumping to `*this`'s
context.
The void pointer argument, `vp`, is passed to the current context to be returned
by the most recent call to `captured_context::operator()` in the same thread.
`fn` is executed with arguments `args` on top of the stack of `this`.
[[Note:] [The behaviour is undefined if `operator()()` is called while `captured_context::current()`
returns `*this` (e.g. resuming an already running context). If the top-level context
function returns, `std::exit()` is called.]]
[[Returns:] [The tuple of void pointer argument passed to the most recent call to
`captured_context::operator()`, if any and a captured_context representing the context
that has been suspended .]]
]

[operator_heading captured_context..operator_equal..operator==]

        bool operator==( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [`true` if `*this` and `other` represent the same execution context,
`false` otherwise.]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_notequal..operator!=]

        bool operator!=( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [[`! (other == * this)]]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_less..operator<]

        bool operator<( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [`true` if `*this != other` is true and the
implementation-defined total order of `captured_context` values places `*this` before
`other`, false otherwise.]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_greater..operator>]

        bool operator>( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [`other < * this`]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_lesseq..operator<=]

        bool operator<=( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [`! (other < * this)`]]
[[Throws:] [Nothing.]]
]

[operator_heading captured_context..operator_greatereq..operator>=]

        bool operator>=( captured_context const& other) const noexcept;

[variablelist
[[Returns:] [`! (* this < other)`]]
[[Throws:] [Nothing.]]
]

[hding captured_context..Non-member function [`operator<<()]]

        template< typename charT, class traitsT >
        std::basic_ostream< charT, traitsT > &
        operator<<( std::basic_ostream< charT, traitsT > & os, captured_context const& other);

[variablelist
[[Efects:] [Writes the representation of `other` to stream `os`.]]
[[Returns:] [`os`]]
]


[endsect]
